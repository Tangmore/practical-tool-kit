### 发布订阅模式（Pub-Sub Pattern）

- 角色：Publisher（发布者）、Subscriber（订阅者）和 Event Channel（事件通道）
- 关系：发布者和订阅者通过事件通道通信，彼此解耦
- 耦合度：低，发布者和订阅者不需要知道对方的存在

😺 订阅者向事件中心订阅事件，发布者向事件中心发布事件，事件中心将事件通知给所有订阅了该事件的订阅者。

### 观察者模式（Observer Pattern）

当一个对象（被观察者、Subject）的状态发生变化时，所有依赖于它的对象（观察者、Observer）都会收到通知，并自动更新。

- 角色：Subject（主题、目标对象）和 Observer（观察者）
- 关系：Subject 维护观察者列表，提供注册、注销接口，当状态变化时通知所有 Observer
  Observer 定义接收通知的接口（如 update 方法）
- 耦合度：相对较高，Subject 需要知道 Observer 的存在

😺 观察者主动向目标对象注册自己，目标对象存储观察者引用，当状态变化时，目标对象通知所有观察者。

### ✨面试常见问题

**观察者模式和发布订阅模式有什么区别？**

观察者模式中，目标（Subject）和观察者（Observer）是直接关联的，当目标状态变化时直接通知所有观察者。
发布订阅模式通过一个事件中心（Event Channel）解耦了发布者和订阅者，发布者无需知道谁订阅了事件，订阅者也不需要知道事件是谁发布的。

- **Vue 中的 EventBus 和 Node.js 的 EventEmitter 属于哪种模式？**
- 答：它们都属于发布订阅模式。

- **如何实现一个支持 once 的 EventEmitter？**
- 答：在注册事件时使用一个标记，执行一次后立即注销。

- **如何防止事件内存泄漏？**
- 答：在注销事件时，确保移除所有绑定的回调函数，避免重复触发已注销的事件。
  观察者不再使用时，需要从 Dep 中移除。

**为什么需要两种模式？**

- **观察者模式**：适合组件内通信，例如一个对象状态改变需要通知多个依赖对象（如 Vue 的 data 变化通知视图更新）
- **发布订阅模式**：适合跨组件、跨模块通信，例如不同模块之间的事件通知（如全局事件总线）

**Vue 中的响应式原理用的是哪种模式？**

Vue2 的响应式系统使用了观察者模式（结合 Object.defineProperty），每个响应式数据属性都会维护一个 Dep（目标），而组件的渲染 Watcher 就是观察者。
当数据变化时，Dep 会通知所有 Watcher 进行更新。Vue3 改用 Proxy，但核心模式仍是观察者模式。

**在什么场景下应该用发布订阅模式？**

当需要解耦事件发布者和订阅者，或者需要支持多对多通信时，例如：

- 不同模块之间的通信
- 插件系统（插件监听核心事件）
- 需要广播事件的场景
