### Event Loop（事件循环）

Event Loop 部分：

1. 解释宏任务与微任务的区别？
2. Node.js 与浏览器事件循环差异？
3. setTimeout(0)与 setImmediate 执行顺序？
4. 如何优化大量微任务导致的性能问题？
5. requestAnimationFrame 属于宏任务还是微任务？

- **目的**：JavaScript 是单线程的，事件循环机制允许 JavaScript 执行异步操作，避免阻塞主线程。
- **组成部分**：
- **调用栈（Call Stack）**：执行函数调用的栈结构，同步任务按顺序执行。
- **任务队列（Task Queue）**：包括宏任务队列（macro task queue）和微任务队列（micro task queue）。
- **宏任务（macro tasks）**：script（整体代码）、setTimeout、setInterval、I/O、UI 渲染等。
- **微任务（micro tasks）**：Promise 回调（then、catch）、MutationObserver、process.nextTick（Node.js）等。

#### 关于 Event Loop

面试官：请解释一下 JavaScript 的事件循环机制。

回答：
JavaScript 是单线程语言，事件循环机制是实现异步编程的核心。它由调用栈、任务队列（分为宏任务队列和微任务队列）组成。

执行过程如下：

1. 同步代码在主线程上执行，形成调用栈，执行完毕后会清空调用栈。
2. 然后检查微任务队列，执行所有微任务（如 Promise 的 then 回调、MutationObserver 等）。微任务会一次性全部执行完毕。
3. 接着从宏任务队列（如 setTimeout、setInterval、I/O 等）中取出一个任务执行。
4. 重复以上过程，形成事件循环。

关键点：在每次宏任务执行完成后，都会清空微任务队列。因此，微任务的优先级高于宏任务。例如，在一个宏任务（如 setTimeout）中产生的微任务，会在下一个宏任务执行前全部执行完。

### 示例代码演示

```javascript
console.log("1"); // 同步任务

setTimeout(() => {
  console.log("2"); // 宏任务
}, 0);

Promise.resolve()
  .then(() => {
    console.log("3"); // 微任务
  })
  .then(() => {
    console.log("4"); // 微任务
  });

console.log("5"); // 同步任务

// 输出顺序：1, 5, 3, 4, 2
```

```js
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => console.log("3"));
}, 0);

Promise.resolve().then(() => {
  console.log("4");
  setTimeout(() => console.log("5"), 0);
});

console.log("6");

// 输出顺序：1 → 6 → 4 → 2 → 3 → 5
// 执行过程解析：
// 同步任务：1、6
// 微任务队列：4 (伴随宏任务5)
// 宏任务队列：2 (伴随微任务3)
// 最后宏任务：5
```

```js
console.log(1);

let promise = new Promise((resolve, reject) => {
  console.log(2);
  resolve("这次一定");
});

promise.then(
  (result) => {
    console.log("fulfilled:", result);
  },
  (reason) => {
    console.log("rejected:", reason);
  }
);

console.log(3);
// 1 2 3 fulfilled: 这次一定
// 首先执行console.log(1)，输出1
// 接着创建promise实例，输出2，因为这里依旧是同步
// 然后碰到resolve的时候，修改结果值
// 到了promise.then会进行异步操作，也就是我们 需要先把执行栈的内容清空，于是就执行console.log(3)，输出3
// 接着才会执行promise.then里面的内容，也就是最后输出“fulfilled: 这次一定”
```

```js
console.log(1);
let promise = new Promise((resolve, reject) => {
  console.log(2);
  setTimeout(() => {
    resolve("这次一定");
    console.log(4);
  });
});
promise.then(
  (result) => {
    console.log("fulfilled:", result);
  },
  (reason) => {
    console.log("rejected:", reason);
  }
);
console.log(3);
```

```js
async function async1() {
  console.log("1");
  await async2();
  console.log("2"); // 微任务
}
async function async2() {
  console.log("3");
}

setTimeout(() => console.log("4"), 0);
async1();
new Promise((res) => {
  console.log("5");
  res();
}).then(() => console.log("6"));
console.log("7");

// 答案：1→3→5→7→2→6→4
```

# 自测

实现 Promise.finally
手写 Promise 链式调用
分析包含 async/await 的事件循环题目
实现支持并发限制的 Promise 调度器
解释 process.nextTick 与 Promise 的执行优先级
